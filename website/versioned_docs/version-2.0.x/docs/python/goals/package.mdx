---
    title: package
    position: 4
---

Create a deployable artifact.

---

The `package` goal creates an artifact that can be deployed or distributed.
[block:callout]
{
  "type": "success",
  "title": "Benefit of Pants: artifacts only include your true dependencies",
  "body": "Because Pants understands the dependencies of your code, and the dependencies of those dependencies, the generated artifact will only include the exact code needed for your package to work. This results in smaller, more focused packages."
}
[/block]
The exact type of artifact depends on the type of target the goal is invoked on.

You can run `./pants package ::` to build all artifacts in your project. Pants will filter to only the relevant targets.
[block:callout]
{
  "type": "info",
  "title": "Use built packages in integration tests",
  "body": "You can depend on a package target in your `python_tests` target through the `runtime_package_dependencies` field. Pants will run the equivalent of `./pants package` beforehand and copy the built artifact into the test's chroot. See [test](doc:python-test-goal) for more imformation."
}
[/block]

[block:api-header]
{
  "title": "Creating a PEX file from a `pex_binary` target"
}
[/block]
Running `package` on a `pex_binary` target will create an executable [PEX file](doc:pex-files).

The PEX file will contain all the code needed to run the binary, namely:
- All Python code and resources the binary transitively depends on.
- The resolved 3rd-party Python dependencies (sdists, eggs and wheels) of all targets the binary transitively depends on.

The PEX metadata will include:
- The entry point specified by the `pex_binary` target.
- The intersection of all interpreter constraints applicable to the code in the Pex.

When defining a `pex_binary` target, you must either specify the `sources` field or the `entry_point` field. If you leave off `entry_point` and set `sources`, Pants will default the entry point to the module name.

Approach #1, `sources` field:
[block:code]
{
  "codes": [
    {
      "code": "python_library(\n  name=\"lib\",\n  # See the below warning about dependency inference for why we do this.\n  sources=[\"*.py\", \"!main.py\"],\n)\n\npex_binary(\n  name=\"app\",\n  sources=[\"main.py\"],\n  # `entry_point` defaults to 'helloworld.main'. We can still \n  # manually set the field if we want, even if `sources` is set.\n)",
      "language": "python",
      "name": "helloworld/BUILD"
    }
  ]
}
[/block]
Approach #2, explicit `entry_point`:
[block:code]
{
  "codes": [
    {
      "code": "python_library(name=\"lib\")\n\npex_binary(\n  name=\"app\",\n  # We can also set to `helloworld.main:my_func`.\n  entry_point=\"helloworld.main\",\n  # Because there are no sources, Pants cannot infer dependencies.\n  dependencies=[\":lib\"],\n)",
      "language": "python",
      "name": "helloworld/BUILD"
    }
  ]
}
[/block]

[block:callout]
{
  "type": "warning",
  "body": "If >1 target \"owns\" the same file, then Pants will not use dependency inference for imports of that file, as Pants cannot disambiguate which you want to use.\n\nBy default, a `python_library()` target will include your binary's source file, so you must be careful to override the `sources` field for any `python_library` target in the same BUILD file.\n\nBad, because both `:lib` and `:app` own the `main.py` file:\n\n```python\npython_library(name=\"lib\")\npex_binary(name=\"app\", sources=[\"main.py\"])\n```\n\nFixed:\n\n```python\npython_library(name=\"app\", sources=[\"*.py\", \"!main.py\"])\npex_binary(name=\"app\", sources=[\"main.py\"])\n```\n\nYou can run `./pants list path/to/app.py` to see which targets \"own\" that file, and to confirm there is only one owner.",
  "title": "Setting the `sources` field can cause issues with dependency inference"
}
[/block]
Run `./pants help pex_binary` for advanced options.
[block:callout]
{
  "type": "warning",
  "title": "PEX files may be platform-specific",
  "body": "If your code's requirements include distributions that include native code, then the resulting PEX file will only run on the platform it was built on. \n\nHowever, if all native code requirements are available as [wheels](https://packaging.python.org/glossary/#term-wheel) for the target platform, then you can cross-build a PEX file on a different source platform by specifying the `platforms` field on the `pex_binary`, e.g. `platforms=[\"linux-x86_64-cp-37-cp37m\", \"macosx_10_15_x86_64-cp-38-cp38\"]`."
}
[/block]

[block:callout]
{
  "type": "info",
  "body": "Because a `.pex` file is simply a ZIP file, you can use the Unix tool `unzip` to inspect the contents. For example, run `unzip -l dist/app.pex` to see all file members.",
  "title": "Tip: inspect the `.pex` file with `unzip`"
}
[/block]

[block:callout]
{
  "type": "warning",
  "title": "Use `resources` instead of `files`",
  "body": "`files` targets will not be included in the built PEX because filesystem APIs like `open()` would not load them as expected. Instead, use the `resources` target or wrap your `pex_binary` in an `archive` target. See [Resources and archives](doc:resources) for further explanation."
}
[/block]
### Examples
[block:code]
{
  "codes": [
    {
      "code": "$ ./pants package helloworld/main.py\n\n17:36:42 [INFO] Wrote dist/helloworld/helloworld.pex",
      "language": "text",
      "name": "Shell"
    }
  ]
}
[/block]
We can also build the same Pex by using the address of the `pex_binary` target, as described [here](doc:targets).
[block:code]
{
  "codes": [
    {
      "code": "$ ./pants package helloworld:app\n\n17:36:42 [INFO] Wrote dist/helloworld/helloworld.pex",
      "language": "text",
      "name": "Shell"
    }
  ]
}
[/block]

[block:api-header]
{
  "title": "Creating a setuptools distribution from a `python_distribution` target"
}
[/block]
Running `package` on a `python_distribution` target will create a standard setuptools-style Python distribution, such as an sdist or a wheel. See [Building Distributions](doc:python-distributions) for details.
[block:api-header]
{
  "title": "Creating a `zip` or `tar` file from an `archive` target"
}
[/block]
See [Resources and archives](doc:resources) for how to create a zip or tar file with built binaries and/or loose files in it. This is often useful when you want to create a PEX binary using the `pex_binary` target, and bundle it with some loose config files.
[block:api-header]
{
  "title": "Creating an AWS Lambda from a `python_awslambda` target"
}
[/block]
If you have the `pants.backend.awslambda.python` backend enabled, then you can use the `package` goal to build AWS Lambdas. See [AWS Lambda](doc:awslambda-python) for more details.