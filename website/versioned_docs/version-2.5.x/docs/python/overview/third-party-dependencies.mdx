---
    title: Third-party dependencies
    position: 2
---

How to use third-party Python libraries in your project.

---

[block:api-header]
{
  "title": "Basic setup"
}
[/block]
To set up third-party dependencies in your project, use a regular  [`requirements.txt`](https://pip.pypa.io/en/stable/user_guide/#requirements-files) file. 

Then,  in the same directory, create a `BUILD` file that invokes the `python_requirements()` macro:
[block:code]
{
  "codes": [
    {
      "code": "flask>=1.1.2,<1.3\nrequests[security]==2.23.0\ndataclasses ; python_version<'3.7'\n",
      "language": "text",
      "name": "requirements.txt"
    },
    {
      "code": "python_requirements()",
      "language": "python",
      "name": "BUILD"
    }
  ]
}
[/block]
Pants will use the `python_requirements()` macro to create a distinct `python_requirement_library` target for each specified requirement.

Pants will then use [dependency inference](doc:targets) by looking at your Python import statements to automatically add those targets to the `dependencies` field. For example:
[block:code]
{
  "codes": [
    {
      "code": "$ ./pants dependencies project/app.py\n//:flask\n//:requests",
      "language": "shell"
    },
    {
      "code": "import flask\nimport requests\n\n...",
      "language": "python",
      "name": "project/app.py"
    }
  ]
}
[/block]
To infer dependencies, Pants needs to know which Python modules a requirement exposes, such as `Django` exposing the module `django`. By default, Pants assumes the module name is the same as the requirement name, normalized to be lowercase and to use dashes, e.g. `typing-extensions` exporting the module `typing_extensions`. Some requirements, however, expose different modules, such as `beautifulsoup4` exposing `bs4`. Pants already defines a [default module mapping](https://github.com/pantsbuild/pants/blob/master/src/python/pants/backend/python/dependency_inference/default_module_mapping.py) for some common Python requirements, but you may need to augment this by teaching Pants additional mappings:
[block:code]
{
  "codes": [
    {
      "code": "python_requirements(\n    # This is only needed for requirements \n    # where the defaults do not work.\n    module_mapping={\n        \"my_distribution\": [\"dist_module\"],\n    },\n)",
      "language": "python",
      "name": "BUILD"
    }
  ]
}
[/block]
You can also add an explicit dependency by adding the `python_requirement_library` target to the `dependencies` field for a target. This will make sure that the dependency is included regardless of if dependency inference can infer it or not. For example:
[block:code]
{
  "codes": [
    {
      "code": "python_library(\n    dependencies=[\n        # We don't have an import statement for this dep, so inference\n        # won't add it automatically. We add it explicitly instead.\n        \"//:psyscopg2-binary\",\n    ],\n)",
      "language": "python",
      "name": "project/BUILD"
    }
  ]
}
[/block]

[block:callout]
{
  "type": "info",
  "title": "Where should I put the requirements.txt?",
  "body": "You can put the file wherever makes the most sense for your project.\n\nIn smaller repositories that only use Python, it's often convenient to put the file at the \"build root\" (top-level), as used on this page.\n\nFor larger repositories or multilingual repositories, it's often useful to have a `3rdparty` or `3rdparty/python` directory. Rather than the target's address being `//:my_requirement`, its address would be `3rdparty/python:my_requirement`, for example.\n\nBUT: if you place your `requirements.txt` in a non-standard location (or give it another name via the `python_requirements(requirements_relpath=..)` argument), you will need to configure `pantsd` to restart for edits to the non-standard filename: see [#9946](https://github.com/pantsbuild/pants/pull/9946)."
}
[/block]

[block:callout]
{
  "type": "warning",
  "title": "Multiple requirements files",
  "body": "Pants can support multiple requirements files (each with a corresponding `python_requirements` macro invocation) in a single repo. \n\nHowever if those requirements overlap there will be multiple targets for the same package, and Pants will not be able to infer which of them a dependency should be on. \n\nIf the version constraints for the overlapping requirements do not conflict, you may wish to refactor the common requirements out of your requirements files and include them with `-r common-requirements.txt`. Then dependency inference will see a single target for each of those common requirements.\n\nIf the version constraints do conflict, or if you otherwise cannot refactor them out, then you will have to specify the relevant dependencies manually.\n\nWe plan to support multiple requirements \"universes\" more robustly in the future, but it will always be preferable to have a single consistently resolvable universe of requirements for your repo, if possible. Pants selects requirement subsets as needed, so adding requirements to a global requirements.txt does not add unnecessary dependencies or bloat."
}
[/block]

[block:api-header]
{
  "title": "Using a lockfile (strongly recommended)"
}
[/block]
Lockfiles are important for reproducible builds. They ensure that the selected versions of all transitive dependencies are consistent, even when third-party libraries release new versions.

If you define a lockfile, Pants will also optimize to avoid resolving requirements more than one time for your project. This greatly speeds up the performance of goals like `test`, `run`, `package`, and `repl`. (See [python-setup](doc:reference-python-setup) for more information on the `resolve_all_constraints` option.)

Pants uses Pip's [constraints file](https://pip.pypa.io/en/stable/user_guide/#constraints-files) feature to support lockfiles. Constraints files tell Pip to use the specified version of a library when encountered, even if it overrides what was specified in your `requirements.txt`.
[block:callout]
{
  "type": "warning",
  "title": "Constraints files are not strongly validated",
  "body": "It is possible to put conflicting versions in a constraints file, and to leave off constraints for some of your dependencies; Pip doesn't check for this. Unfortunately, the onus is on you to make sure that your constraints file is sound."
}
[/block]
To use this feature, create a `constraints.txt` file that pins versions of all your transitive third-party dependencies.

Then tell Pants about the file with the `requirement_constraints` option in the `[python-setup]` scope, like this:
[block:code]
{
  "codes": [
    {
      "code": "[python-setup]\nrequirement_constraints = \"constraints.txt\"",
      "language": "toml",
      "name": "pants.toml"
    },
    {
      "code": "certifi==2019.6.16\nchardet==3.0.2\nidna==2.7\nrequests==2.23.0\nurllib3==1.25.6",
      "language": "text",
      "name": "constraints.txt"
    }
  ]
}
[/block]
Pants will then pass this constraints file to Pip whenever resolving third party dependencies.
[block:callout]
{
  "type": "info",
  "title": "How do I generate a lockfile?",
  "body": "The simplest approach is to create a virtual environment for your project and then to use this to generate a `constraints.txt` file. See below for an example script.\n\nYou may alternatively use a tool like [Poetry](https://python-poetry.org) or [Pipenv](https://pipenv.pypa.io/en/latest/), then use their `export` commands to generate a `constraints.txt` file."
}
[/block]

[block:callout]
{
  "type": "warning",
  "title": "Need support for multiple lockfiles?",
  "body": "For now, Pants only supports one single global lockfile. But, we are considering adding support for multiple lockfiles. Please message us on [Slack](doc:community) if you would like this feature - we would appreciate feedback on your use case."
}
[/block]

[block:api-header]
{
  "title": "Advanced requirements usage"
}
[/block]
### Inline requirements

Sometimes you may want to use a certain dependency without adding it to your `requirements.txt`. For example, you may want to use a different version than what is in `requirements.txt`. Or, you may want to only use the requirement in one location and don't want it to discoverable by all targets.

Pants allows you to define inline requirements with the target type `python_requirement_library`, like this:
[block:code]
{
  "codes": [
    {
      "code": "python_requirement_library(\n    name=\"old_requests\",\n    requirements=[\"requests==2.8.0\"],\n)\n\npex_binary(\n    name=\"app\",\n    sources=[\"app.py\"],\n    dependencies=[\n        \":old_requests\",\n    ],\n)",
      "language": "python",
      "name": "project/BUILD"
    }
  ]
}
[/block]
If any of your requirements expose modules with names different than the project name and not already covered by Pants's [default module mapping](https://github.com/pantsbuild/pants/blob/master/src/python/pants/backend/python/dependency_inference/default_module_mapping.py), you can teach Pants about it by setting `module_mapping`:
[block:code]
{
  "codes": [
    {
      "code": "python_requirement_library(\n    name=\"old_requests\",\n    requirements=[\"ansicolors==1.18.0\"],\n    module_mapping={\"ansicolors\": [\"colors\"]},\n)",
      "language": "python",
      "name": "project/BUILD"
    }
  ]
}
[/block]
### Version control or local requirements

You might be used to using pip's proprietary VCS-style requirements for this, like `git+https://github.com/django/django.git#egg=django`. However, this proprietary format does not work with Pants.

Instead of pip VCS-style requirements:

```
git+https://github.com/django/django.git#egg=Django
git+https://github.com/django/django.git@stable/2.1.x#egg=Django
git+https://github.com/django/django.git@fd209f62f1d83233cc634443cfac5ee4328d98b8#egg=Django
```

Use direct references from [PEP 440](https://www.python.org/dev/peps/pep-0440/#direct-references):

```
Django@ git+https://github.com/django/django.git
Django@ git+https://github.com/django/django.git@stable/2.1.x
Django@ git+https://github.com/django/django.git@fd209f62f1d83233cc634443cfac5ee4328d98b8
```

You can also install from local files using [PEP 440 direct references](https://www.python.org/dev/peps/pep-0440/#direct-references). You must use an absolute path to the file, and you should ensure that the file exists on your machine.

```
Django @ file:///Users/pantsbuild/prebuilt_wheels/django-3.1.1-py3-none-any.whl
```

Pip still works with these PEP 440-compliant formats, so you won't be losing any functionality by switching to using them.
[block:callout]
{
  "type": "info",
  "title": "Version control via SSH",
  "body": "When using version controlled direct references hosted on private repositories with SSH access:\n```\ntarget@ git+ssh://git@github.com:/myorg/myrepo.git@myhash\n```\n...you may see errors like:\n```\n Complete output (5 lines):\n  git@github.com: Permission denied (publickey).\n  fatal: Could not read from remote repository.\n  Please make sure you have the correct access rights\n  and the repository exists.\n  ----------------------------------------\n```\n\nTo fix this, Pants needs to be configured to pass relevant SSH specific environment variables to processes. To do so, you can add the following to `pants.toml`:\n```\n[subprocess-environment]\nenv_vars.add = [\n  \"SSH_AUTH_SOCK\",\n]\n```\nPants invokes processes hermetically by default, and will not pass in environment variables to processes like PEX, or pip unless they are requested."
}
[/block]

[block:api-header]
{
  "title": "Using custom repositories"
}
[/block]
If you host your own wheels at a custom index (aka "cheese shop"), you can instruct Pants to use it with the option `indexes` in the `[python-repos]` scope.
[block:code]
{
  "codes": [
    {
      "code": "[python-repos]\nindexes.add = [\"https://custom-cheeseshop.net/simple\"]",
      "language": "toml",
      "name": "pants.toml"
    }
  ]
}
[/block]
To exclusively use your custom index—i.e. to not use PyPI—use `indexes = [..]` instead of `indexes.add = [..]`.
[block:api-header]
{
  "title": "Tip: Set up a virtual environment (optional)"
}
[/block]
While Pants itself doesn't need a [virtualenv](https://docs.python.org/3/library/venv.html), it may be useful to create one for working with your tooling outside Pants, such as your IDE.

You can create a virtualenv using standard Python tooling—such as [Python's builtin `venv` module](https://docs.python.org/3/library/venv.html)—along with running Pants to query for all of your Python requirements.

For example, this script will first create a venv, and then generate a `constraints.txt` file.
[block:code]
{
  "codes": [
    {
      "code": "#!/usr/bin/env bash\n\nset -euo pipefail\n\n# You can change these constants.\nPYTHON_BIN=python3\nVIRTUALENV=build-support/.venv\nPIP=\"${VIRTUALENV}/bin/pip\"\nREQUIREMENTS_FILE=requirements.txt\nCONSTRAINTS_FILE=constraints.txt\n\n\"${PYTHON_BIN}\" -m venv \"${VIRTUALENV}\"\n\"${PIP}\" install pip --upgrade\n# Install all our requirements.txt, and also any 3rdparty\n# dependencies specified outside requirements.txt, e.g. via a\n# handwritten python_requirement_library target.\n\"${PIP}\" install \\\n  -r \"${REQUIREMENTS_FILE}\" \\\n  -r <(./pants dependencies --type=3rdparty ::)\necho \"# Generated by build-support/generate_constraints.sh on $(date)\" > \"${CONSTRAINTS_FILE}\"\n\"${PIP}\" freeze --all >> \"${CONSTRAINTS_FILE}\"",
      "language": "shell",
      "name": "build-support/generate_constraints.sh"
    }
  ]
}
[/block]

[block:callout]
{
  "type": "warning",
  "title": "This script only captures handwritten dependencies that are consumed",
  "body": "This script will capture all requirements in your `requirements.txt`, whether they are actually consumed by your code or not.\n\nHowever, due to how the `./pants dependencies` goal works, it will only capture 3rdparty dependencies specified outside `requirements.txt` (i.e., via a handwritten `python_requirement_library target`) if those are actually used by your code."
}
[/block]